# 시간 복잡도(Time Complexity)
- 입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼만큼 걸리는지
## Big-O 표기법
- Big-O(최악), Big-Ω(최선), Big-θ(평균)
- 빅오 표기법은 최악의 시간을 고려할 수 있다는 점에서 주로 사용된다.
  - 최선의 경우를 고려할 경우 문제가 발생했을 때, 로직의 많은 부분을 파악해야하므로 파악하는데 시간이 오래 걸린다는 단점이 있다.
  - 평균 고려할 경우 최악의 경우가 발생했을 때 최선의 경우와 같은 고민이 생긴다.
### Big-O 표기법 종류
- O(1)
  - 일정한 복잡도(constant complexity)라고 하며, 입력값이 증가하더라도 시간이 늘어나지 않는다.
- O(n)
  - 선형 복잡도(linear complexity)라고 부르며, 입력값이 증가함에 따라 시간 또한 같은 비율로 증가.
  - 2n, 3n 같은 경우도 생길 수 있는데 입력값이 커지면 커질수록 n앞의 계수의 영향력은 점점 적어지기 때문에 모두 O(n)으로 표기한다.
- O(log n)
  - 로그 복잡도(logarithmic complexity)라고 부르며, O(1) 다음으로 빠른 시간 복잡도를 가진다.
  - 노드를 이동할 때마다 경우의 수가 절반으로 줄어드는 BST(Binary Search Tree)와 같은 것을 의미.
- O(n^2)
  - 2차 복잡도(quadratic complexity)라고 부르며, 입력값이 시간이 증가함에 따라 n의 제곱수의 비율로 증가하는 것을 의미한다.
  - n^3, n^4 들도 입력값이 커질수록 지수의 영향력이 퇴색되므로 모두 n^2로 표기한다.
- O(2n)
  - 기하급수적 복잡도(exponential complexity)라고 부르며, 가장 느린 시간 복잡도를 가진다.
  - 재귀로 구현하는 피보나치 수열을 생각하면 된다. 이는 피보나치 함수를 한 번 실행할 때마다 재귀함수를 2번 call하므로 한 번 실행에 2번씩 늘어난다.
  - 만약 시간복잡도가 2n이라면 다른 방식을 고려하는 것이 정신 건강에 좋을 것이다.

# 그래프 탐색
- 하나의 Vertex(정점)으로부터 시작해 차례대로 모든 정점들을 한 번씩 방문하는 것.
## 너비 우선 탐색(BFS, Breadth-first Search)
- root 노드 또는 임의의 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법
- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법
- 주로 두 노드 사이의 최단 경로 또는 임의의 경로를 찾을 때 BFS를 사용한다.
### BFS의 특징
- 재귀적으로 동작하지 않는다.
- 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다.
	- 이는 무한루프에 빠지는 것을 방지하기 위함이다.
- BFS는 가까운 정점을 모두 저장한 후 순서대로 방문해야 하므로 FIFO 구조를 사용하는 Queue를
사용하는것이 좋다.(가장 먼저 넣은 노드들부터 방문하기 때문이다.)
### Queue를 이용한 BFS의 동작 과정
![image](https://github.com/Sangh0Yoon/Tech_Interview_preparation/assets/100823955/37ab5c9d-efcf-4006-856c-ff7331dd3ae0)

1. 시작점을 1번 노드라고 할 때, 노드 1을 먼저 방문하고 큐에 삽입하며 방문 처리를 한다.
   - 큐 상태 : 1
2. 큐에서 노드 1을 꺼내면서 인접한 정점인 2,3을 큐에 삽입하고 방문처리를 한다.
   - 큐 상태 : 2 3
3. 큐에서 노드 2를 꺼내면서 인접하면서 방문하지 않은 노드 8을 큐에 삽입하고 방문 처리한다.
   - 큐 상태 : 3 8
4. 큐에서 노드 3 을 꺼내고 인접한 노드인 4,5를 큐에 삽입한 후 방문 처리한다.
   - 큐 상태 : 8 4 5
5. 큐에서 노드 8을 꺼내고 인접한 노드 6,7을 큐에 삽입한 후 방문 처리한다.
   - 큐 상태 : 4 5 6 7
6. 그래프 내의 모든 노드를 방문하였으므로 지금부터는 큐에서 모든 노드를 차레대로 꺼낸다.
7. 최종적으로 노드의 탐색 순서는 1 -> 2 -> 3 -> 8 -> 4 -> 5 -> 6 -> 7
### BFS 시간 복잡도
- 인접 리스트로 표현된 그래프 : O(V+E)
  - 반복 횟수가 일정하지 않은 for loop에 if문이 들어가 있다.
  - 어떤 라인은 모든 간선(edge)에 대해서 한 번씩 비교할 것이기 때문에 총 E번 반복할 것이고, 각 노드를 한 번씩 모두 방문하여 V의 시간이 걸릴 것이다.
- 인접 행렬로 표현된 그래프 : O(V^2)
  - 노드 하나당 for loop에 의해 O(V)의 시간이 걸리고, 이 for loop은 while loop을 통해 모든 정점을 한 번씩 방문할 때마다 실행되므로 V번 반복 실행된다.
### BFS 코딩 문제
- 프로그래머스 Lv.2 미로 탈출

## 깊이 우선 탐색(DFS, Depth-first Search)

### DFS의 특징

### Queue를 이용한 DFS의 동작 과정

### DFS 시간 복잡도

### DFS 코딩 문제
